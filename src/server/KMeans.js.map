{"version":3,"sources":["KMeans.es6"],"names":["KMeans","c","centroids","findCentroids","newCE","findClusters","reduce","a","b","concat","new_error","clusters","same","i","length","old_error","kmeans","k","knn","push","x","y","distance","Math","floor","map","Infinity","cc","forEach","sort","round","clu","j","center","dataset","dp","closest","closest_distance","dist","Number","pow","root","sqrt"],"mappings":"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","file":"KMeans.js","sourcesContent":["class KMeans {\n\n    kmeans(c){\n        let centroids = this.findCentroids(c);\n        let newCE = this.findClusters(\n            centroids,\n            c.reduce((a, b) => { return a.concat(b); })\n        );\n\n        let new_error = newCE[0];\n        let clusters = newCE[1];\n\n        let same = true;\n        for(let i = 0; i < new_error.length; i++){\n            if(new_error[i] !== this.old_error[i]){\n                same = false;\n                this.old_error = new_error;\n                break;\n            }\n        }\n        if(same){\n            return [clusters, centroids];\n        }else{\n            return this.kmeans(clusters);\n        }\n    }\n\n    constructor(k, knn){\n        let clusters = [];\n\n        let c = [];\n        for(let i = 0; i < knn.length; i++){\n            c.push([knn[i].x, knn[i].y, knn[i].distance]);\n            if(i > 0 && i % Math.floor(knn.length / k) == 0){\n                clusters.push(c);\n                c = [];\n            }\n        }\n        if(c.length > 0) clusters.push(c);\n\n        this.old_error = clusters.map(() => {return Infinity;});\n\n        let cc = this.kmeans(clusters);\n        cc[0].forEach((c) => {\n            c.sort((a, b) => { return a[2] > b[2]; });\n        });\n        cc[1] = cc[1].map((c) => {\n            return [Math.round(c[0]), Math.round(c[1])];\n        });\n        return cc;\n    }\n\n\n    findCentroids(clusters){\n\n        let centroids = [];\n\n        for(let i = 0; i < clusters.length; i++){\n            let clu = clusters[i];\n            let x = 0;\n            let y = 0;\n            for(let j = 0; j < clu.length; j++){\n                x += clu[j][0];\n                y += clu[j][1];\n            }\n            let center = [x / clu.length, y / clu.length];\n            centroids.push(center);\n        }\n        return centroids;\n    }\n\n    findClusters(centroids, dataset){\n\n        let clusters = centroids.map((c) => { return []; });\n        let new_error = centroids.map(() => {return 0;});\n        for(let i = 0; i < dataset.length; i++){\n            let dp = dataset[i];\n            let closest = false;\n            let closest_distance = Infinity;\n            for(let j = 0; j < centroids.length; j++){\n                let center = centroids[j];\n                let distance = this.dist(center, dp);\n                if(distance < closest_distance){\n                    closest = j;\n                    closest_distance = distance;\n                }\n            }\n            new_error[closest] = Number(new_error[closest]) + Math.pow(closest_distance, 2);\n\n            clusters[closest].push(dp);\n        }\n        return [new_error, clusters];\n    }\n\n    dist(a, b){\n        let root = 0;\n        for(let i = 0; i < 2; i++){\n            root += Math.pow((a[i] - b[i]), 2);\n        }\n        return Math.sqrt(root);\n    }\n}\n\nexport default KMeans;"]}